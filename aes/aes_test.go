package aes

import (
	"bytes"
	"math/rand"
	"testing"
)

type keySize struct{
	size uint8
	key []uint8
}

var keys = map[string]keySize{
	"0":{0,nil},
	"1":{1,[]uint8{0x01}},
	"15":{15,[]uint8{0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32}},
	"16":{16,[]uint8{0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10}},
	"24":{24,[]uint8{0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef}},
	"32":{32,[]uint8{0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10}},
	"33":{33,[]uint8{0x01,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10}},
}

const datasize = 1 //MB
var iv = []uint8{0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}

func TestKeysize(t *testing.T) {
	N := datasize*1024*1024
	data := make([]byte,N, N)
	for i:=0 ; i<N ; i++ {data[i]=byte(rand.Int()%256)}

	for k,v := range keys  {
		c,err := AesEncrypt(data,v.key,iv)
		if err!=nil {
			t.Errorf("encrypt has error! keysize is %v byte, err_info:%v \n",k, err)
		}

		p,err := AesDecrypt(c,v.key,iv)
		if err!=nil {
			t.Errorf("decrypt has error! keysize is %v byte, err_info:%v \n",k,err)
		}

		if !bytes.Equal(data, p) {
			t.Errorf("decypher and plaintext is not euqal! \n")
		}
	}

}

func TestCorrectness(t *testing.T) {
	N := datasize*1024*1024
	data := make([]byte,N, N)
	for i:=0 ; i<N ; i++ {data[i]=byte(rand.Int()%256)}

	c,err := AesEncrypt(data,keys["16"].key,iv)
	if err!=nil {
		t.Errorf("encrypt has error! err_info:%v \n",err)
	}

	p,err := AesDecrypt(c,keys["16"].key,iv)
	if err!=nil {
		t.Errorf("decrypt has error! err_info:%v \n",err)
	}

	if !bytes.Equal(data, p) {
		t.Errorf("CBC mode has error! \n")
	}

}

func BenchmarkLoopsForCbcEnc(b *testing.B) {
	N := datasize*1024*1024
	b.SetBytes(int64(N))
	b.ReportAllocs()
	data := make([]byte,N, N)
	for i:=0 ; i<N ; i++ {data[i]=byte(rand.Int()%256)}
	b.ResetTimer()

	for i:=0 ; i<b.N ; i++ {
		AesEncrypt(data,keys["16"].key,iv)
	}
}

func BenchmarkLoopsForCbcDec(b *testing.B) {
	N := datasize*1024*1024
	b.SetBytes(int64(N))
	b.ReportAllocs()
	data := make([]byte,N, N)
	for i:=0 ; i<N ; i++ {data[i]=byte(rand.Int()%256)}
	c,_ := AesEncrypt(data,keys["16"].key,iv)

	b.ResetTimer()
	for i:=0 ; i<b.N ; i++ {
		AesDecrypt(c,keys["16"].key,iv)
	}
}
